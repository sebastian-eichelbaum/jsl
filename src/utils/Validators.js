/**
 * Calculate a password score based on special chars, numbers, upper/lower mix and length.
 *
 * @param {String} pass - The password to check
 * @param {Number} minLength - The password length minimum
 *
 * @return {Number} A score in [0,4], 4 is best
 */
function passwordScore(pass, minLength = 8) {
    const specialCharRegex = /[^A-Za-z0-9]/g;
    const lowercaseRegex = /(.*[a-z].*)/g;
    const uppercaseRegex = /(.*[A-Z].*)/g;
    const numberRegex = /(.*[0-9].*)/g;
    const repeatCharRegex = /(\w)(\1+\1+\1+)/g;

    const hasSpecialChar = specialCharRegex.test(pass);
    const hasLowerCase = lowercaseRegex.test(pass);
    const hasUpperCase = uppercaseRegex.test(pass);
    const hasNumber = numberRegex.test(pass);
    const hasRepeatChars = repeatCharRegex.test(pass);

    // Warning: this is a lot of black magic and hard to reason about.
    let score = 0;
    if (pass?.length >= minLength) {
        // If the password combines upper/lower/special/... give some cudos for that (and it already has a  min length
        score =
            // The user combined some of these: add a point each
            (hasLowerCase +
                hasUpperCase +
                hasNumber +
                hasSpecialChar -
                // Deduct one point to ensure that using only one of these chars is assumed bad.
                1) *
            // scale to make length a bigger influence?
            1.0;

        // If a certain length is reached, add points
        // Linear score for pass with length 8 to 20
        let lengthScore = (Math.max(pass.length, 8) - 8) / (20 - 8);
        if (!hasRepeatChars) {
            score += 2 * lengthScore;
        }

        // Round and clamp to [0,4]
        return Math.max(Math.min(Math.round(score), 4), 0);
    }
    return score;
}

/**
 * A collection of validator functions. They should not be used directly in
 * vuetify rule definitions as their "this" is unbound.
 *
 * NOTE: do not export. Should not be used directly. use one of the appropriate
 * wrappers generated by ValidatorFactory instead.
 */
export class Validations {
    /**
     * Construct the validator and provide a msg handler (usually a translation
     * function).
     *
     * @param {Function} handler a function accepting a string as parameter,
     *     returning a string. The handler can receive additional arguments in a second parameter as object. Some
     *     validators pass values like { min: 3 } to allow customizing the message.
     */
    constructor(handler) {
        this.m_handler = handler;
    }

    /**
     * The message handler. @see constructor for details.
     *
     * @return the handler function
     */
    get handler() {
        return this.m_handler;
    }

    /**
     * Check if the value is not empty.
     * Use: :rules=[Validator.required(),...]
     *
     * @param {Boolean} trim  - if true, the string is trimmed before checking emptyness.
     *
     * @return {Function} that returns True if valid or handler("form.msg.inputRequired")
     */
    required(trim = true) {
        return (value) => {
            // This ensures that non-strings also check, even if trim is not defined 
            const v = trim ? value?.trim?.() || value : value;
            if (!v) return this.m_handler("form.msg.inputRequired");
            return true;
        };
    }

    /**
     * Call this to make a validator that checks for a minimum length.
     * Use: :rules=[Validator.lengthMin(3),...]
     *
     * @param {Number} min the min length to satisfy
     * @param {Boolean} trim - if true, trim before testing length
     *
     * @return {Function} that returns {Boolean|String}. True if valid or
     *     handler("form.msg.inputTooShort", min)
     */
    lengthMin(min, trim = true) {
        return (value) => {
            const v = trim ? value?.trim() : value;
            if (v?.length >= min) return true;
            return this.m_handler("form.msg.inputTooShort", { min: min });
        };
    }

    /**
     * Call this to make a validator that checks for a maximum length.
     * Use: :rules=[Validator.lengthMax(3),...]
     *
     * @param {Number} max the max length to satisfy
     * @param {Boolean} trim - if true, trim before testing length
     *
     * @return {Function} that returns {Boolean|String}. True if valid or
     *     handler("form.msg.inputTooLong", max)
     */
    lengthMax(max, trim = true) {
        return (value) => {
            const v = trim ? value?.trim() : value;
            if (value?.length <= max) return true;
            return this.m_handler("form.msg.inputTooLong", { max: max });
        };
    }

    /**
     * Call this to make a validator that checks for a maximum length.
     * Use: :rules=[Validator.lengthRange(3,10),...]
     *
     * @param {Number} min the min length to satisfy
     * @param {Number} max the max length to satisfy
     * @param {Boolean} trim - if true, trim before testing length
     *
     * @return {Function} that returns {Boolean|String}. True if valid or
     *     handler("form.msg.inputTooShort") or handler("form.msg.inputTooLong")
     */
    lengthRange(min, max, trim = true) {
        return (value) => Validations.combined(value, this.lengthMin(min, trim), this.lengthMax(max, trim));
    }

    /**
     * Validate for Email addresses. Use :rules=[Validator.email(), ...].
     *
     * @return {Function} that returns {Boolean|String}. True if valid or handler("form.msg.inputInvalidEmail")
     */
    email() {
        return (value) => {
            const pattern =
                /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

            if (!value) return this.m_handler("form.msg.inputRequired");
            if (!pattern.test(value)) return this.m_handler("form.msg.inputInvalidEmail");
            return true;
        };
    }

    /**
     * Validate for sufficiently strong passwords. Use :rules=[Validator.passwordScore(2), ...].
     *
     * @param {Number} minLength - Min pass length to accept.
     * @param {Number} minScore - Min pass score. Should be in [0,4].
     *
     * @return {Function} that returns {Boolean|String}. True if valid or
     *     - handler("form.msg.inputRequired")
     *     - handler("form.msg.inputPasswordTooWeak")
     *     - handler("form.msg.inputPasswordTooShort")
     */
    passwordScore(minScore = 1, minLength = 8) {
        return (value) => {
            if (!value) return this.m_handler("form.msg.inputRequired");
            if (value?.length < minLength) return this.m_handler("form.msg.inputPasswordTooShort", { min: minLength });
            if (passwordScore(value, minLength) < minScore) return this.m_handler("form.msg.inputPasswordTooWeak");
            return true;
        };
    }

    /**
     * Validate for passwords matching each other. Use :rules=[Validator.passwordMatch(password), ...].
     *
     * @param {String} other - A password to compare to. Usually, use set a `const password = ref("")` as v-model in the password field.
     *
     * @return {Function} that returns {Boolean|String}. True if valid or
     *     - handler("form.msg.inputRequired")
     *     - handler("form.msg.inputPasswordsDoNotMatch")
     */
    passwordMatch(other) {
        return (value) => {
            if (!value) return this.m_handler("form.msg.inputRequired");
            if (value !== other.toString()) return this.m_handler("form.msg.inputPasswordsDoNotMatch");
            return true;
        };
    }

    /**
     * Allows to blacklist a set of chars.
     *
     * @param {Array} chars - An array of single-character strings. Each char is added to the blacklist.
     * @returns {Function} that returns {Boolean|String}. True if valid or
     *     - handler("form.msg.inputBlacklistedChar", {char:..., chars:... })
     *
     * @throws Error if the chars parameter is not an array of length-1 strings.
     */
    charBlacklist(chars) {
        if (!Array.isArray(chars)) {
            throw new Error("Character list must be an array");
        }
        if (!chars.every((c) => (typeof c === "string" || c instanceof String) && c.length == 1)) {
            throw new Error("Each element in the character array must be a string of length 1.");
        }

        return (value) => {
            for (const c of chars) {
                if (value.includes(c))
                    return this.m_handler("form.msg.inputBlacklistedChar", { char: c, chars: chars.toString() });
            }
            return true;
        };
    }

    /**
     * Combine a set of validations. If one fails, its message is returned.
     *
     * @param value - The value to check
     * @param {Array<Function>} ...funcs The functions to combine.
     */
    static combined(value, ...funcs) {
        for (const f of funcs) {
            const result = f(value);
            if (result !== true) {
                return result;
            }
        }

        return true;
    }
}

import BindMembers from "@jsl/utils/BindMembers";
import { localization } from "@jsl/Localization";

export class ValidatorFactory {
    /**
     * Make a validator that calls a given handler per message.
     *
     * @param {Function} handler @see Validations.constructor. A function
     *     (String)=> String
     */
    static custom(handler) {
        return BindMembers(new Validations(handler));
    }

    /**
     * Make a validator that returns messages as they are.
     */
    static identity() {
        return BindMembers(new Validations((msg) => msg));
    }

    /**
     * Make a validator that runs all messages through jsl Localization
     * (vue-i18n).
     */
    static translated() {
        return BindMembers(new Validations((msg, ...args) => localization.t(msg, ...args)));
    }
}

export default ValidatorFactory.translated();
